# Stone Complier
《两周自制脚本语言》千叶滋 著，C# 实现版本

## 流程
* 1.词法分析
    - 正则匹配拆分
* 2.语法分析
    - 使用BNF来表示语法
    - 查找模式匹配，一边获取单词一边构造抽象语法树，根据语法规则将stone语言改写为C#代码
* 3.解释器
    - 从抽象语法树的根节点遍历到叶节点，计算各个节点的内容
* 4.添加函数
    - 扩充BNF语法规则
    - 暂且规定stone语言的函数必定有返回值，没有return语句，所以就把最后一句的结果返回
    - def语句仅能用于最外层代码，暂不支持函数的嵌套定义：不支持用户在代码块block中定义函数
    - 明确变量的时间范围——生存周期，和空间范围——作用域。  
    变量的作用域：通常由嵌套结构实现，需要为每一种作用域准备一个单独的环境，并根据需要来嵌套环境。  
    查找变量时，程序首先查找与最内层作用域对应的环境，如果没找到再向外逐层查找。  
    stone语言中目前不支持在函数内嵌套定义函数，也不考虑{}代码块的独立作用域，因此其始终只有2个作用域：全局、局部。  
    变量的生存周期可以通过环境对象的创建及清除时机来控制
    - 闭包是一种特殊的匿名函数，可以实现把函数赋值给变量，或者作为参数传递给其他函数
* 5.基于类的面向对象
    - 仅支持单一继承
    - 由于不含静态类型，无法使用接口的概念
    - 不支持定义带参构造函数
    - 无法显示定义构造函数，对象一旦创建，就会从上往下依次执行大括号中的类定义语句，这就作为stone语言的"构造函数"
    - {}之间可以出现def语句或者赋值表达式，如果赋值对象不是已有的全局变量，则将其视为类新添加的字段
    - 支持继承，用extends标识
    - 类似支持方法覆盖，因为子类方法被添加到环境中在父类方法之后，但这样做会导致无法调用被覆盖的父类方法。
    - 不支持方法重载，同一个类中无法定义参数个数或类型不同的同名方法
    - stone语言的字段与方法之间没有明确的区分，方法是一种以Function对象为值的字段
    - 采用闭包的形式来表现StoneObject对象的内部结构，即利用环境能保存字段值的特性来表示对象。将对象视作一种环境，就很容易实现对该对象自身(this)的方法调用与变量访问，指代自身的this可省略。所谓“采用闭包的形式”，可这样理解：将成员函数引用的成员变量视为“自由变量”，实例化时构造函数会将变量与方法记录进env（相当于定义闭包），等实际调用实例的方法时，就会去定义时的环境来读写变量。
    - 对于类的成员函数，会有3层嵌套环境：最内层的用于记录参数和局部变量；外一层用于记录StoneObject对象的字段与方法；最外层用于记录定义类时的全局变量。  
* 6.添加数组
    - 数组长度无法中途修改
    - 数组元素的类型无需保持一致，例如可以是["hello", 123]
    - 数组本身也可以作为一个元素，来表示多维数组 [[...], [...]]
* 7.优化变量读写性能（提升速度）
    - 优化的核心思想：提前计算好能够计算的值。这一节本质就是提前计算程序会出现怎样的变量。
    - 注意：这部分不会涉及类与对象的优化，后面会介绍其他方法
    - 【局部变量】的数量与变量名在函数定义完成后即全部确认，程序无法再为函数添加局部变量或者改变变量名称。语言处理器在函数定义完成后遍历对应的抽象语法树节点，即可获取该节点使用的所有函数参数与局部变量（名称和数量都确定了）
    - 从使用哈希表存储变量名称与值的对应关系，引用时通过哈希表来查找；改成->使用数组直接存储值，在每个引用变量处（解析得到的抽象语法树Name节点对象的字段里）记录对应的数组index，这样引用时直接索引数组即可，无需计算哈希值。注意：Name节点对象的字段里，不仅要记录变量所在的数组元素下标，还要记录环境所处的层数（从内向外计数）
    - 如果需要满足程序内容可随时增加，而不是必须一次性提交全部代码，则对于【全局变量】还需要记录变量名称与index之间的对应关系（依然需要使用哈希表），不仅能通过编号查找变量值，还要能通过变量名查找变量值。因为对于新增的代码，如果之前未保存变量名信息，就无法在Name节点对象里记录下index，无法用于后续引用变量时的索引。
    - 为抽象语法树的节点类增加Lookup方法，参数是Symbols对象（哈希表，记录变量名与保存位置的对应关系。与环境Env相似，都能通过多个串连的方式来表示作用域的嵌套结构），该方法用于在函数定义时查找其用到的所有变量，并确定它们在环境中的保存位置，以及在节点对象中记录这些保存位置。Lookup方法会在Eval之前被调用，也是从抽象语法树的根节点开始遍历所有节点，在遍历时如果发现赋值表达式左侧的变量名则会从Symbols中查找，对于首次出现的变量名 会在环境中为其分配一个保存位置并记录进Symbols；除了赋值，还会在所有引用该变量的节点中记录保存位置。
    - 修改后的Eval方法将根据保存位置，从环境中获取变量值或者对其进行更新
    - 实际测试：fib(33)，优化前：9.36/9.18/9.03s，优化后：6.11/6.08/6.03s，提升了30%。C#原生：0.03/0.03/0.04s，差距好大啊！
 * 8.优化对象操作性能（减少内存、提升速度）
    - 之前使用环境Env来表达StoneObject，环境中存储了两种键值对：字段名vs数值、方法名vsFunction对象。这种实现的内存利用率很低，因为同一个类实例化出来的对象都具有相同的方法，没必要为每个StoneObject都存一遍相关的键值对。新的设计会让所有同类的对象共享方法：为每个类创建一个ClassInfo对象，记录与该类中方法相关的信息；StoneObject对象包含对ClassInfo的引用，以及记录该对象自己的字段数值。这样就使得每个StoneOject占用的内存量减少了。【这一步是让ClassInfo统一记录方法函数的定义内容】
    - 继续使用数组代替哈希表来实现环境，完成字段值与方法定义的获取，从而加快查找速度、提高对象操作性能。此外通过数组这种方式也可以进一步减少内存使用，因为不必在每个StoneObject中重复存很多遍字段名称和方法名称。StoneObject只需要记录字段的值即可，字段名称将与方法信息一起保存进ClassInfo中。【这一步是让ClassInfo统一记录字段名符号表和方法名符号表】
    - 类似局部变量读写优化那样，是否也可以提前把类的字段/方法的index提前存起来用于后续查找呢？由于Stone语言是动态数据类型语言，对象的类型只有在实际运行时才能获知（对象可以是简单明确地new出来的，也可能是某个函数返回的多种类型可能之一的结果），因此语言处理器无法提前找到该对象中字段或方法的保存位置。只能在确定类型之后，通过变量名和方法名来查找其在数组中的保存位置，然后再根据索引获取到相应的对象。但this对象（隐式地引用this，暂不支持显示）是个例外，由于调用时已经知道this所指的类型，要么是自身要么是子类，所以就能事先获得方法和字段的保存位置，记录进语法树的节点里。（对于相互继承的类，字段和方法在数组中的保存位置应当相同。注意Stone语言仅支持单一继承，多重继承无法使得字段保存在同一位置）
    - 最终实现将在执行class语句、对类进行定义时，查找其中由def语句完成的方法定义，确定方法内部引用了由this所指对象的方法与字段的位置。如果找到这样的位置，语言处理器会将其记录于对应抽象语法树的节点对象中。之后实际执行程序时，就可以通过预先记录的位置来优化执行性能。symbols串联来表示作用域的嵌套结构：SymbolThis(只保存this) -> MemberSymbols(字段) -> MemberSymbols(方法) -> Symbols(全局)。
    - 内联缓存（Inline Cache）：根据经验，同一位置出现的对象通常是同一类型。语言处理器可以在执行程序的同时查找字段的保存位置，并将该结果与对象所属类型一并成对保存在抽象语法树节点的新增字段里。之后如果再次执行同一段程序，语言处理器将首先判断当时的对象类型，如果和之前相同，则直接使用上次的查找结果。这一方法可以针对非this对象的字段或方法引用进一步优化性能，不再只能通过名称来查找环境中的保存位置。
    - 实际测试：类里包裹fib成员函数。未优化：13.15/12.95/13.24s，优化变量读写&未优化对象操作：13.25/12.94/12.84s，优化变量读写&优化对象操作&未内联缓存：9.52/9.08/8.94s（注意不要显示使用this来引用方法或字段）

## 概念
* 词法分析器 lexical analyzer / lexer / scanner
* 语法分析器 parser
* 单词 token
* BNF（一种表示语法的范式）举例：四则运算表达式的语法规则
*     factor:     NUMBER | "(" expression ")"      factor由单独的整型字面量构成，或者由括号包起的expression构成（注：这里体现了递归循环）
*     term:       factor { ( "*" | "/" ) factor }  term可以由单独的factor构成，也可以后续再接乘除另一个或多个factor项（注：大括号表示某模式至少出现0次，中括号表示某模式出现0次或1次，括号将里面的内容当作一个完整的模式）
*     expression: term { ( "+" | "-" ) term }      expression可以由单独的term构成，也可以后续再接加减另一个或多个term项（注：规则里还内含了加减乘除的优先级）

## 大纲
### 1. 基础
- √ 语法功能，整数四则运算，字符串处理，支持变量，if while基本控制语句，动态数据类型，支持注释
- √ 词法分析器，正则库
- √ 抽象语法树，BNF
- √ 语法解释器，解析器组合子库
- √ 设计基本的解释器，GluonJ

### 2. 增强
- √ 增加static方法调用支持
- √ 增加类与对象的语法，闭包实现
- √ 增加数组功能
- √ 增强解释器功能，能执行函数、支持闭包语法

### 3. 性能优化
- 优化访问变量性能，搜索id而不是变量名
- 优化调用对象和字段的性能，搜索id而不是变量名，增加内联缓存
- 虚拟机 中间代码
- 支持静态数据类型，增加类型检查

### 4. 高级
- 手工设计词法分析器，正则匹配
- √ 语法分析基本算法，LL语法
- √ 解析器组合子库的源码分析
- GluonJ注意事项
- 抽象语法树，节点对象的类会包含各种类型的方法，可以用其他设计模式实现而不用GluonJ

## Stone语言的BNF语法规则
### 基础语法规则
不考虑优先级，用其他方法处理  
* `primary: "(" expr ")" | NUMBER | IDENTIFIER | STRING`  
基本元素：括号括起的表达式、整型字面量、标识符、字符串字面量  
* `factor: "-" primary | primary`  
todo 感觉可以和primary中的NUMBER合并到一起，... | ["-"] NUMBER | ...
* `expr: factor { OP factor }`  
双目运算符连接的两侧
* `block: "{" [statement] {(";" | EOL) [statement]} "}"`  
由大括号括起来的statement语句序列，语句之间用分块或换行符分割，支持空语句  
todo 为啥不用{[statement] (";" | EOL)}来表示？代码块中最后一句可以省略分号或换行符
* `simple: expr`  
简单语句
* `statement: "if" expr block ["else" block] | "while" expr block | simple`  
可以是if语句、wile语句、或者简单表达式语句
* `program: [statement] (";" | EOL)`  
一行stone语言程序，可以表示空行  
todo 怎样区分一行program和statement？program既可以是处于代码块之外的一条语句，也可以是一行完整的程序

### 函数相关的语法规则
* `param: IDENTIFIER`  
定义时的形参，倒是不需要指定类型，直接写个变量名就好
* `params: param { "," param }`
参数之间以逗号分隔
* `param_list: "(" [params] ")"`  
定义时用括号括起来，但可以没有参数
* `def: "def" IDENTIFIER param_list block`  
中间IDENTIFIER是函数名
* `args: expr { "," expr }`  
调用时的实参
* `postfix: "(" [args] ")"`  
调用时用括号括起的实参列表，叫做postfix是因为以后还要扩充，去代表不同的类似后缀一样的情况  

以下与原有不同：
* `primary: ( "(" expr ")" | NUMBER | IDENTIFIER | STRING ) { postfix }`  
todo 应该只有IDENTIFIER后面有可能加{ postfix }吧？为啥要统一放在全体的末尾
* `simple: expr [ args ]`  
当语句中只含有一个函数调用时，可以不加括号传参
* `program: [def | statement] (";" | EOL)`

### 闭包的语法规则
* `primary: "fun" param_list block | 原先的primary定义`

### 类的语法规则
* `member: def | simple`
* `class_body: "{" [member] { (";" | EOL) [member]} "}"`
* `def_class: "class" IDENTIFIER [ "extends" IDENTIFIER ] class_body`
* `postfix: "." IDENTIFIER | "(" [args] ")"`  
不仅能表示实参序列，还支持基于句点.来调用类的字段与方法
* `program: [def_class | def | statement] (";" | EOL)`  

### 数组的语法规则
* `elements: expr { "," expr }`  
* `primary: ( "[" [elements] "]" | "(" expr ")" | NUMBER | IDENTIFIER | STRING ) { postfix }`  
* `postfix: "[" expr "]" | "." IDENTIFIER | "(" [args] ")"`  
支持数组下标

## 数据类型

环境中可以记录的名值对有哪些：
* 整数值 int对象
* 字符串 string对象
* 函数 Function对象
* 原生函数 NativeFunction对象
* 类定义 ClassInfo对象
* Stone语言的对象 StoneObject对象
* Stone语言的数组 object[]数组对象
